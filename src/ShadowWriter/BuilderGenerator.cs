// Copyright © Stefan Stolz, 2025

using System;
using System.Collections.Immutable;
using System.Reflection;
using System.Text;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace ShadowWriter;

public record BuilderGeneratorArgs(bool BuildAttributeFound, bool IsRecord, RecordDeclarationSyntax? RecordDeclarationSyntax)
{
    public static BuilderGeneratorArgs Empty => new(false, false, null);
}

[Generator]
public sealed class BuilderGenerator : IIncrementalGenerator
{
    private const string Namespace = "ShadowWriter";
    private const string BuilderAttributeName = "BuilderAttribute";
    private readonly string version = "0.0.0";

    private string AttributeSourceCode => $@"// <auto-generated/>

using System;
using System.CodeDom.Compiler;
using System.Runtime.CompilerServices;

namespace {Namespace}
{{
    [CompilerGenerated]
    [GeneratedCode(""ShadowWriter"", ""{version}"")]
    [System.AttributeUsage(AttributeTargets.Class)]
    internal sealed class {BuilderAttributeName} : System.Attribute
    {{

    }}
}}";

    public BuilderGenerator()
    {
        var versionAttribute = this.GetType().Assembly.GetCustomAttribute<AssemblyFileVersionAttribute>();
        if (versionAttribute != null) {
            this.version = versionAttribute.Version;
        }
    }

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
                                                     "BuilderAttribute.g.cs",
                                                     SourceText.From(AttributeSourceCode, Encoding.UTF8)));

        // IncrementalValuesProvider<BuilderGeneratorArgs> providerForRecords
        //     = context.SyntaxProvider
        //              .CreateSyntaxProvider(((node, _) => node is ClassDeclarationSyntax),
        //                                    (syntaxContext, _) => GetBuilderGeneratorArgs(syntaxContext))
        //              .Where(t => t.BuildAttributeFound && t.IsRecord);
        //
        // context.RegisterSourceOutput(context.CompilationProvider.Combine(providerForRecords.Collect()),
        //                              (ctx, t) => this.GenerateCode(ctx, t.Left, t.Right));

        var recordProvider = context.SyntaxProvider.ForAttributeWithMetadataName(
                                        fullyQualifiedMetadataName: $"{Namespace}.{BuilderAttributeName}",
                                        predicate: static (node, _) => node is RecordDeclarationSyntax,
                                        transform: static (ctx, _) => GetBuilderGeneratorArgs(ctx))
                                    .Where(t => t.BuildAttributeFound && t.IsRecord);

        context.RegisterSourceOutput(context.CompilationProvider.Combine(recordProvider.Collect()),
                                     (ctx, t) => this.GenerateCode(ctx, t.Left, t.Right));
    }

    private void GenerateCode(SourceProductionContext ctx, Compilation compilation, ImmutableArray<BuilderGeneratorArgs> args)
    {
        if (args.IsEmpty) return;
    }

    private static BuilderGeneratorArgs GetBuilderGeneratorArgs(GeneratorAttributeSyntaxContext syntaxContext)
    {
        var symbol = syntaxContext.SemanticModel.GetDeclaredSymbol(syntaxContext.TargetNode) as INamedTypeSymbol;
        if (symbol is null) return BuilderGeneratorArgs.Empty;
        if (!IsRecord(symbol)) return BuilderGeneratorArgs.Empty;

        return new BuilderGeneratorArgs(true, true, syntaxContext.TargetNode as RecordDeclarationSyntax);
    }

    private static bool IsRecord(INamedTypeSymbol typeSymbol)
    {
        return typeSymbol.IsRecord;
    }
}
