using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace ShadowWriter;

[Generator]
public sealed class NullObjectGenerator : IIncrementalGenerator {
    private const string Namespace = "ShadowWriter";
    private const string AttributeName = "NullObjectAttribute";

    private const string AttributeSourceCode = $@"// <auto-generated/>

namespace {Namespace}
{{
    [System.AttributeUsage(System.AttributeTargets.Interface)]
    internal sealed class {AttributeName} : System.Attribute
    {{
        public string Name {{ get; }}

        public {AttributeName}(string name)
        {{
            this.Name = name;
        }}

        public {AttributeName}()
        {{
            this.Name = string.Empty;
        }}
    }}
}}";

    public void Initialize(IncrementalGeneratorInitializationContext context) {
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
            "NullObjectAttribute.g.cs",
            SourceText.From(AttributeSourceCode, Encoding.UTF8)));

        // Filter classes annotated with the [Report] attribute. Only filtered Syntax Nodes can trigger code generation.
        var provider = context.SyntaxProvider
                              .CreateSyntaxProvider(
                                  (s, _) => s is InterfaceDeclarationSyntax,
                                  (ctx, _) => GetClassDeclarationForSourceGen(ctx))
                              .Where(t => t.ReportAttributeFound)
                              .Select((t, _) => t);

        // Generate the source code.
        context.RegisterSourceOutput(
            context.CompilationProvider.Combine(provider.Collect()),
            ((ctx, t) => GenerateCode(ctx, t.Left, t.Right)));
    }

    /// <summary>
    /// Generate code action.
    /// It will be executed on specific nodes (ClassDeclarationSyntax annotated with the [Report] attribute) changed by the user.
    /// </summary>
    /// <param name="context">Source generation context used to add source files.</param>
    /// <param name="compilation">Compilation used to provide access to the Semantic Model.</param>
    /// <param name="args">Nodes annotated with the [NullObject] attribute that trigger the generate action.</param>
    private void GenerateCode(SourceProductionContext context, Compilation compilation,
        ImmutableArray<NullObjectGeneratorArgs> args) {
        foreach (var arg in args) {
            var interfaceDeclaration = arg.InterfaceDeclarationSyntax;
            var semanticModel = compilation.GetSemanticModel(interfaceDeclaration.SyntaxTree);
            if (semanticModel.GetDeclaredSymbol(interfaceDeclaration) is not INamedTypeSymbol interfaceSymbol)
                continue;

            var namespaceName = interfaceSymbol.ContainingNamespace.ToDisplayString();

            var interfaceName = interfaceSymbol.Name;
            var className = interfaceSymbol.Name;

            if (className.StartsWith("I", StringComparison.Ordinal)) {
                className = className.Substring(1);
            }

            className = $"Null{className}";

            if (!string.IsNullOrWhiteSpace(arg.ClassName)) {
                className = arg.ClassName;
            }

            var body = this.CreateBody(semanticModel, compilation, interfaceSymbol, interfaceDeclaration);

            var code = $$"""
                         using System;
                         using System.Threading.Tasks;

                         namespace {{namespaceName}};

                         public sealed partial class {{className}} : {{interfaceName}}
                         {
                           private {{className}}()
                           {}

                           public static {{interfaceName}} Instance { get; } = new {{className}}();

                         {{body}}
                         }
                         """;

            var cleanNamespace = namespaceName.Replace(".", "");

            context.AddSource($"{cleanNamespace}{className}.g.cs", SourceText.From(code, Encoding.UTF8));
        }
    }

    private string CreateBody(SemanticModel semanticModel, Compilation compilation, INamedTypeSymbol interfaceSymbol, InterfaceDeclarationSyntax interfaceDeclaration) {
        var sb = new StringBuilder();

        foreach (var method in interfaceDeclaration.Members) {
            var ds = semanticModel.GetDeclaredSymbol(method);

            if (ds is IMethodSymbol ms) {
                var parameters = new List<string>();

                foreach (var parameterSymbol in ms.Parameters) {
                    parameters.Add($"{parameterSymbol.Type.ToDisplayString()} {parameterSymbol.Name}");
                }

                string result = string.Empty;

                if (ms.ReturnsVoid) {
                    result = "{ }";
                }
                else if (IsValueTask(ms.ReturnType)) {
                    result = """
                             {
                                return ValueTask.CompletedTask;
                             }
                             """;
                }
                else if (ms.ReturnType.IsValueType) {
                    result = """
                             {
                               return default;
                             }
                             """;
                }
                else if (IsIEnumerableOfT(ms.ReturnType)) {
                    result = """
                             {
                                yield break;
                             }
                             """;
                }
                else if (IsTask(ms.ReturnType)) {
                    result = """
                             {
                                return Task.CompletedTask;
                             }
                             """;
                }


                if (string.IsNullOrWhiteSpace(result)) {
                    sb.Append($"public partial {ms.ReturnType.ToDisplayString()} {ms.Name}({string.Join(", ", parameters)});").AppendLine();
                }
                else {
                    sb.Append($"public {ms.ReturnType.ToDisplayString()} {ms.Name}({string.Join(", ", parameters)})").AppendLine();
                    sb.AppendLine(result);
                }
            }

            if (ds is IPropertySymbol property) {
                if (property.GetMethod is not null && property.SetMethod is null) {
                    sb.AppendLine($"public {property.Type.ToDisplayString()} {property.Name} => default;");
                }
                else if (property.SetMethod is not null && property.GetMethod is not null) {
                    sb.AppendLine($"public {property.Type.ToDisplayString()} {property.Name}");
                    sb.AppendLine("{");
                    sb.AppendLine("get => default;");
                    sb.AppendLine("set => _ = value;");
                    sb.AppendLine("}");
                }
            }

            sb.AppendLine();
        }

        return sb.ToString();

        bool IsTask(ITypeSymbol typeSymbol) {
            var taskType = compilation.GetTypeByMetadataName("System.Threading.Tasks.Task");

            return SymbolEqualityComparer.Default.Equals(typeSymbol, taskType);
        }

        bool IsValueTask(ITypeSymbol typeSymbol) {
            var taskType = compilation.GetTypeByMetadataName("System.Threading.Tasks.ValueTask");

            return SymbolEqualityComparer.Default.Equals(typeSymbol, taskType);
        }

        bool IsIEnumerableOfT(ITypeSymbol typeSymbol) {
            if (typeSymbol is INamedTypeSymbol namedTypeSymbol) {
                return namedTypeSymbol.ConstructedFrom.SpecialType == SpecialType.System_Collections_Generic_IEnumerable_T;
            }

            return false;
        }
    }


    /// <summary>
    /// Checks whether the Node is annotated with the [Report] attribute and maps syntax context to the specific node type (ClassDeclarationSyntax).
    /// </summary>
    /// <param name="context">Syntax context, based on CreateSyntaxProvider predicate</param>
    /// <returns>The specific cast and whether the attribute was found.</returns>
    private static NullObjectGeneratorArgs GetClassDeclarationForSourceGen(
        GeneratorSyntaxContext context) {
        var classDeclarationSyntax = (InterfaceDeclarationSyntax)context.Node;

        // Go through all attributes of the class.
        foreach (AttributeListSyntax attributeListSyntax in classDeclarationSyntax.AttributeLists) {
            foreach (AttributeSyntax attributeSyntax in attributeListSyntax.Attributes) {
                if (context.SemanticModel.GetSymbolInfo(attributeSyntax).Symbol is not IMethodSymbol attributeSymbol)
                    continue; // if we can't get the symbol, ignore it

                string attributeName = attributeSymbol.ContainingType.ToDisplayString();

                string? className = null;

                if (attributeSyntax.ArgumentList?.Arguments.Count == 1) {
                    var x = attributeSyntax.ArgumentList.Arguments[0];

                    className = x.Expression.ToString().Trim('"');
                }


                // Check the full name of the [Report] attribute.
                if (attributeName == $"{Namespace}.{AttributeName}")
                    return new NullObjectGeneratorArgs(true, className, classDeclarationSyntax);
            }
        }

        return new NullObjectGeneratorArgs(false, null, classDeclarationSyntax);
    }
}