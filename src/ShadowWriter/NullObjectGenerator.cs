using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Reflection;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace ShadowWriter;

[Generator]
public sealed class NullObjectGenerator : IIncrementalGenerator
{
    private const string Namespace = "ShadowWriter";
    private const string NullObjectAttributeName = "NullObjectAttribute";
    private const string ClassNameAttributeName = "ClassNameAttribute";

    private readonly string version = "0.0.0";

    private string AttributeSourceCode => $@"// <auto-generated/>

using System;
using System.CodeDom.Compiler;
using System.Runtime.CompilerServices;

namespace {Namespace}
{{
    [CompilerGenerated]
    [GeneratedCode(""ShadowWriter"", ""{version}"")]
    [System.AttributeUsage(AttributeTargets.Interface | AttributeTargets.Class)]
    internal sealed class {NullObjectAttributeName} : System.Attribute
    {{

    }}

    [CompilerGenerated]
    [GeneratedCode(""ShadowWriter"", ""{version}"")]
    [System.AttributeUsage(System.AttributeTargets.Interface)]
    internal sealed class {ClassNameAttributeName} : System.Attribute
    {{
        public string Name {{ get; }}

        public {ClassNameAttributeName}(string name)
        {{
            this.Name = name;
        }}

        public {ClassNameAttributeName}()
        {{
            this.Name = string.Empty;
        }}
    }}
}}";

    public NullObjectGenerator()
    {
        var versionAttribute = this.GetType().Assembly.GetCustomAttribute<AssemblyFileVersionAttribute>();
        if (versionAttribute != null)
        {
            this.version = versionAttribute.Version;
        }
    }

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
            "NullObjectAttribute.g.cs",
            SourceText.From(AttributeSourceCode, Encoding.UTF8)));

        IncrementalValuesProvider<InterfaceNullObjectGeneratorArgs> providerForInterfaces
            = context.SyntaxProvider
                .CreateSyntaxProvider(
                    (s, _) => s is InterfaceDeclarationSyntax,
                    (ctx, _) => GetInterfaceDeclarationForSourceGen(ctx))
                .Where(t => t.NullObjectAttributeFound)
                .Select((t, _) => t);

        IncrementalValuesProvider<ClassNullObjectGeneratorArgs> providerForClasses
            = context.SyntaxProvider
                .CreateSyntaxProvider(
                    (s, _) => s is ClassDeclarationSyntax,
                    (ctx, _) => GetClassDeclarationForSourceGen(ctx))
                .Where(t => t.NullObjectAttributeFound)
                .Select((t, _) => t);

        // Generate the source code.
        context.RegisterSourceOutput(
            context.CompilationProvider.Combine(providerForInterfaces.Collect()),
            (ctx, t) => this.GenerateCode(ctx, t.Left, t.Right));

        context.RegisterSourceOutput(
            context.CompilationProvider.Combine(providerForClasses.Collect()),
            (ctx, t) => this.GenerateCode(ctx, t.Left, t.Right));
    }

    private void GenerateCode(SourceProductionContext context, Compilation compilation,
        ImmutableArray<ClassNullObjectGeneratorArgs> args)
    {
        foreach (ClassNullObjectGeneratorArgs? arg in args)
        {
            ClassDeclarationSyntax classDeclaration = arg.ClassDeclarationSyntax;
            SemanticModel semanticModel = compilation.GetSemanticModel(classDeclaration.SyntaxTree);
            ISymbol? classSymbol =
                semanticModel.GetDeclaredSymbol(classDeclaration);

            bool makeNullableEnabled = compilation.Options.NullableContextOptions == NullableContextOptions.Enable;

            string namespaceName = classSymbol!.ContainingNamespace.ToDisplayString();
            string className = classSymbol.Name;

            if (classSymbol is ITypeSymbol ts)
            {
                ImmutableArray<INamedTypeSymbol> implementedInterfaces = ts.AllInterfaces;


                string body = this.CreateBodyClassBody(implementedInterfaces, compilation);


                string code = $$"""
                                using System;
                                using System.CodeDom.Compiler;
                                using System.Runtime.CompilerServices;
                                using System.Threading.Tasks;

                                #nullable {{(makeNullableEnabled ? "enable" : "disable")}}

                                namespace {{namespaceName}};

                                [CompilerGenerated]
                                [GeneratedCode("ShadowWriter", "{{version}}")]
                                public sealed partial class {{className}}
                                {
                                  private {{className}}()
                                  {}

                                  public static {{classSymbol}} Instance { get; } = new {{className}}();

                                {{body.TrimEnd()}}
                                }
                                """;

                string cleanNamespace = namespaceName.Replace(".", "");
                context.AddSource($"{cleanNamespace}{className}.g.cs", SourceText.From(code, Encoding.UTF8));
            }
        }
    }

    /// <summary>
    ///     Generate code action.
    ///     It will be executed on specific nodes (ClassDeclarationSyntax annotated with the [Report] attribute) changed by the
    ///     user.
    /// </summary>
    /// <param name="context">Source generation context used to add source files.</param>
    /// <param name="compilation">Compilation used to provide access to the Semantic Model.</param>
    /// <param name="args">Nodes annotated with the [NullObject] attribute that trigger the generate action.</param>
    private void GenerateCode(SourceProductionContext context, Compilation compilation,
        ImmutableArray<InterfaceNullObjectGeneratorArgs> args)
    {
        static AttributeSyntax? GetAttributeByName(InterfaceDeclarationSyntax interfaceDeclaration,
            string attributeName)
        {
            return interfaceDeclaration.AttributeLists
                .SelectMany(list => list.Attributes)
                .FirstOrDefault(attr =>
                {
                    string name = attr.Name.ToString();
                    // Optional: Handling f√ºr Attribute mit oder ohne "Attribute"-Suffix
                    return name == attributeName || name == attributeName + "Attribute";
                });
        }


        foreach (InterfaceNullObjectGeneratorArgs? arg in args)
        {
            InterfaceDeclarationSyntax interfaceDeclaration = arg.InterfaceDeclarationSyntax;
            SemanticModel semanticModel = compilation.GetSemanticModel(interfaceDeclaration.SyntaxTree);
            if (semanticModel.GetDeclaredSymbol(interfaceDeclaration) is not INamedTypeSymbol interfaceSymbol)
            {
                continue;
            }

            string namespaceName = interfaceSymbol.ContainingNamespace.ToDisplayString();

            string interfaceName = interfaceSymbol.Name;
            string className = interfaceSymbol.Name;

            if (className.StartsWith("I", StringComparison.Ordinal))
            {
                className = className.Substring(1);
            }

            className = $"Null{className}";

            AttributeSyntax? attributeSyntax = GetAttributeByName(interfaceDeclaration, "ShadowWriter.ClassName");
            if (attributeSyntax?.ArgumentList?.Arguments.Count == 1)
            {
                AttributeArgumentSyntax x = attributeSyntax.ArgumentList.Arguments[0];

                className = x.Expression.ToString().Trim('"');
            }

            bool makeNullableEnabled = compilation.Options.NullableContextOptions == NullableContextOptions.Enable;

            string body = this.CreateBody(semanticModel, compilation, interfaceDeclaration);

            string code = $$"""
                            using System;
                            using System.Threading.Tasks;
                            using System.CodeDom.Compiler;
                            using System.Runtime.CompilerServices;

                            #nullable {{(makeNullableEnabled ? "enable" : "disable")}}

                            namespace {{namespaceName}};

                            [CompilerGenerated]
                            [GeneratedCode("ShadowWriter", "{{version}}")]
                            public sealed partial class {{className}} : {{interfaceName}}
                            {
                              private {{className}}()
                              {}

                              public static {{interfaceName}} Instance { get; } = new {{className}}();

                              {{body}}
                            }
                            """;

            string cleanNamespace = namespaceName.Replace(".", "");

            context.AddSource($"{cleanNamespace}{className}.g.cs", SourceText.From(code, Encoding.UTF8));
        }
    }

    private string CreateBodyClassBody(ImmutableArray<INamedTypeSymbol> implementedInterfaces, Compilation compilation)
    {
        bool IsIEnumerableOfT(ITypeSymbol typeSymbol)
        {
            if (typeSymbol is INamedTypeSymbol namedTypeSymbol)
            {
                return namedTypeSymbol.ConstructedFrom.SpecialType ==
                       SpecialType.System_Collections_Generic_IEnumerable_T;
            }

            return false;
        }

        IndentedStringBuilder codeBuilder = new("  ", 1);

        foreach (INamedTypeSymbol namedTypeSymbol in implementedInterfaces)
        {
            foreach (ISymbol member in namedTypeSymbol.GetMembers())
            {
                if (member is IPropertySymbol propertySymbol)
                {
                    if (propertySymbol.GetMethod is not null)
                    {
                        string returnValue = "default";

                        if (propertySymbol.Type.SpecialType == SpecialType.System_String)
                        {
                            returnValue = "string.Empty";
                        }
                        else if (IsIEnumerableOfT(propertySymbol.Type))
                        {
                            returnValue = "[]";
                        }

                        if (propertySymbol.SetMethod is null)
                        {
                            // Get only
                            codeBuilder.AppendLine(
                                $"public {propertySymbol.Type.ToDisplayString()} {propertySymbol.Name} => {returnValue};");
                        }
                        else
                        {
                            // Get and Set
                            codeBuilder.AppendLine(
                                $"public {propertySymbol.Type.ToDisplayString()} {propertySymbol.Name}");
                            codeBuilder.AppendLine("{");
                            codeBuilder.AppendLine($"get => {returnValue};");
                            codeBuilder.AppendLine("set => _ = value;");
                            codeBuilder.AppendLine("}");
                        }
                    }
                }
                else if (member is IMethodSymbol ms)
                {
                    if (ms.MethodKind == MethodKind.PropertyGet || ms.MethodKind == MethodKind.PropertySet)
                    {
                        continue;
                    }

                    string x = member.Name;

                    List<string> parameters = GeneratorParameterList(ms);

                    codeBuilder.AppendLine($"// {x}");

                    string methodReturn = GenerateMethodReturn(compilation, ms);

                    bool makePartial = string.IsNullOrWhiteSpace(methodReturn);

                    codeBuilder.Append("public ");
                    if (makePartial)
                    {
                        codeBuilder.Append("partial ");
                    }

                    codeBuilder.Append(ms.ReturnType.ToDisplayString());
                    codeBuilder.Append(" ");
                    codeBuilder.Append(member.Name);
                    codeBuilder.Append("(");
                    codeBuilder.Append(string.Join(", ", parameters));
                    codeBuilder.Append(")");

                    if (!string.IsNullOrWhiteSpace(methodReturn))
                    {
                        codeBuilder.AppendLine();
                        codeBuilder.AppendLine(methodReturn);
                    }
                    else
                    {
                        codeBuilder.AppendLine(";");
                    }
                }
            }
        }

        return codeBuilder.ToString();
    }

    private string CreateBody(SemanticModel semanticModel, Compilation compilation,
        InterfaceDeclarationSyntax interfaceDeclaration)
    {
        IndentedStringBuilder sb = new("  ", 1);

        foreach (MemberDeclarationSyntax method in interfaceDeclaration.Members)
        {
            ISymbol? ds = semanticModel.GetDeclaredSymbol(method);

            if (ds is IMethodSymbol ms)
            {
                List<string> parameters = GeneratorParameterList(ms);

                string result = GenerateMethodReturn(compilation, ms);


                if (string.IsNullOrWhiteSpace(result))
                {
                    sb.Append(
                            $"public partial {ms.ReturnType.ToDisplayString()} {ms.Name}({string.Join(", ", parameters)});")
                        .AppendLine();
                }
                else
                {
                    sb.Append($"public {ms.ReturnType.ToDisplayString()} {ms.Name}({string.Join(", ", parameters)})")
                        .AppendLine();
                    sb.AppendLine(result);
                }
            }

            if (ds is IPropertySymbol property)
            {
                if (property.GetMethod is not null && property.SetMethod is null)
                {
                    sb.AppendLine($"public {property.Type.ToDisplayString()} {property.Name} => default;");
                }
                else if (property.SetMethod is not null && property.GetMethod is not null)
                {
                    sb.AppendLine($"public {property.Type.ToDisplayString()} {property.Name}");
                    sb.AppendLine("{");
                    sb.AppendLine("get => default;");
                    sb.AppendLine("set => _ = value;");
                    sb.AppendLine("}");
                }
            }

            sb.AppendLine();
        }

        return sb.ToString();
    }

    private static List<string> GeneratorParameterList(IMethodSymbol ms)
    {
        List<string> parameters = new();

        foreach (IParameterSymbol? parameterSymbol in ms.Parameters)
        {
            parameters.Add($"{parameterSymbol.Type.ToDisplayString()} {parameterSymbol.Name}");
        }

        return parameters;
    }

    private static string GenerateMethodReturn(Compilation compilation, IMethodSymbol ms)
    {
        string result = string.Empty;

        if (ms.ReturnsVoid)
        {
            result = "{ }";
        }
        else if (IsValueTask(ms.ReturnType))
        {
            result = """
                     {
                        return ValueTask.CompletedTask;
                     }
                     """;
        }
        else if (ms.ReturnType.IsValueType)
        {
            result = """
                     {
                       return default;
                     }
                     """;
        }
        else if (IsIEnumerableOfT(ms.ReturnType))
        {
            result = """
                     {
                        yield break;
                     }
                     """;
        }
        else if (IsTask(ms.ReturnType))
        {
            result = """
                     {
                        return Task.CompletedTask;
                     }
                     """;
        }

        return result;

        bool IsValueTask(ITypeSymbol typeSymbol)
        {
            INamedTypeSymbol? taskType = compilation.GetTypeByMetadataName("System.Threading.Tasks.ValueTask");

            return SymbolEqualityComparer.Default.Equals(typeSymbol, taskType);
        }

        bool IsIEnumerableOfT(ITypeSymbol typeSymbol)
        {
            if (typeSymbol is INamedTypeSymbol namedTypeSymbol)
            {
                return namedTypeSymbol.ConstructedFrom.SpecialType ==
                       SpecialType.System_Collections_Generic_IEnumerable_T;
            }

            return false;
        }

        bool IsTask(ITypeSymbol typeSymbol)
        {
            INamedTypeSymbol? taskType = compilation.GetTypeByMetadataName("System.Threading.Tasks.Task");

            return SymbolEqualityComparer.Default.Equals(typeSymbol, taskType);
        }
    }


    /// <summary>
    ///     Checks whether the Node is annotated with the [Report] attribute and maps syntax context to the specific node type
    ///     (ClassDeclarationSyntax).
    /// </summary>
    /// <param name="context">Syntax context, based on CreateSyntaxProvider predicate</param>
    /// <returns>The specific cast and whether the attribute was found.</returns>
    private static InterfaceNullObjectGeneratorArgs GetInterfaceDeclarationForSourceGen(
        GeneratorSyntaxContext context)
    {
        InterfaceDeclarationSyntax classDeclarationSyntax = (InterfaceDeclarationSyntax)context.Node;

        // Go through all attributes of the class.
        foreach (AttributeListSyntax attributeListSyntax in classDeclarationSyntax.AttributeLists)
        {
            foreach (AttributeSyntax attributeSyntax in attributeListSyntax.Attributes)
            {
                if (context.SemanticModel.GetSymbolInfo(attributeSyntax).Symbol is not IMethodSymbol attributeSymbol)
                {
                    continue; // if we can't get the symbol, ignore it
                }

                string attributeName = attributeSymbol.ContainingType.ToDisplayString();

                // Check the full name of the [Report] attribute.
                if (attributeName == $"{Namespace}.{NullObjectAttributeName}")
                {
                    return new InterfaceNullObjectGeneratorArgs(true, classDeclarationSyntax);
                }
            }
        }

        return new InterfaceNullObjectGeneratorArgs(false, classDeclarationSyntax);
    }


    /// <summary>
    ///     Checks whether the Node is annotated with the [Report] attribute and maps syntax context to the specific node type
    ///     (ClassDeclarationSyntax).
    /// </summary>
    /// <param name="context">Syntax context, based on CreateSyntaxProvider predicate</param>
    /// <returns>The specific cast and whether the attribute was found.</returns>
    private static ClassNullObjectGeneratorArgs GetClassDeclarationForSourceGen(
        GeneratorSyntaxContext context)
    {
        ClassDeclarationSyntax classDeclarationSyntax = (ClassDeclarationSyntax)context.Node;

        // Go through all attributes of the class.
        foreach (AttributeListSyntax attributeListSyntax in classDeclarationSyntax.AttributeLists)
        {
            foreach (AttributeSyntax attributeSyntax in attributeListSyntax.Attributes)
            {
                if (context.SemanticModel.GetSymbolInfo(attributeSyntax).Symbol is not IMethodSymbol attributeSymbol)
                {
                    continue; // if we can't get the symbol, ignore it
                }

                string attributeName = attributeSymbol.ContainingType.ToDisplayString();

                // Check the full name of the [Report] attribute.
                if (attributeName == $"{Namespace}.{NullObjectAttributeName}")
                {
                    return new ClassNullObjectGeneratorArgs(true, classDeclarationSyntax);
                }
            }
        }

        return new ClassNullObjectGeneratorArgs(false, classDeclarationSyntax);
    }
}