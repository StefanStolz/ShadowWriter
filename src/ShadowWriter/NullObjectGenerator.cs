using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Reflection;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace ShadowWriter;

[Generator]
public sealed class NullObjectGenerator : IIncrementalGenerator
{
    private readonly DiagnosticDescriptor unsupportedReturnTypeDescriptor = new DiagnosticDescriptor(
        id: "SHADOWWRITER0001",
        title: "Unsupported return type",
        messageFormat:
        "Unsupported return type '{0}'. This type is not handled by the source generator. Please provide a manual implementation.",
        category: nameof(NullObjectGenerator),
        defaultSeverity: DiagnosticSeverity.Error,
        isEnabledByDefault: true
    );

    private const string Namespace = "ShadowWriter";
    private const string NullObjectAttributeName = "NullObjectAttribute";
    private const string ClassNameAttributeName = "ClassNameAttribute";

    private readonly string version = "0.0.0";

    private string AttributeSourceCode => $@"// <auto-generated/>

using System;
using System.CodeDom.Compiler;
using System.Runtime.CompilerServices;

namespace {Namespace}
{{
    [CompilerGenerated]
    [GeneratedCode(""ShadowWriter"", ""{version}"")]
    [System.AttributeUsage(AttributeTargets.Interface | AttributeTargets.Class)]
    internal sealed class {NullObjectAttributeName} : System.Attribute
    {{

    }}

    [CompilerGenerated]
    [GeneratedCode(""ShadowWriter"", ""{version}"")]
    [System.AttributeUsage(System.AttributeTargets.Interface)]
    internal sealed class {ClassNameAttributeName} : System.Attribute
    {{
        public string Name {{ get; }}

        public {ClassNameAttributeName}(string name)
        {{
            this.Name = name;
        }}

        public {ClassNameAttributeName}()
        {{
            this.Name = string.Empty;
        }}
    }}
}}";

    public NullObjectGenerator()
    {
        var versionAttribute = this.GetType().Assembly.GetCustomAttribute<AssemblyFileVersionAttribute>();
        if (versionAttribute != null)
        {
            this.version = versionAttribute.Version;
        }
    }

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
            "NullObjectAttribute.g.cs",
            SourceText.From(AttributeSourceCode, Encoding.UTF8)));

        IncrementalValuesProvider<InterfaceNullObjectGeneratorArgs> providerForInterfaces
            = context.SyntaxProvider
                .CreateSyntaxProvider(
                    (s, _) => s is InterfaceDeclarationSyntax,
                    (ctx, _) => GetInterfaceDeclarationForSourceGen(ctx))
                .Where(t => t.NullObjectAttributeFound)
                .Select((t, _) => t);

        IncrementalValuesProvider<ClassNullObjectGeneratorArgs> providerForClasses
            = context.SyntaxProvider
                .CreateSyntaxProvider(
                    (s, _) => s is ClassDeclarationSyntax,
                    (ctx, _) => GetClassDeclarationForSourceGen(ctx))
                .Where(t => t.NullObjectAttributeFound)
                .Select((t, _) => t);

        // Generate the source code.
        context.RegisterSourceOutput(
            context.CompilationProvider.Combine(providerForInterfaces.Collect()),
            (ctx, t) => this.GenerateFullClassForInterface(ctx, t.Left, t.Right));

        context.RegisterSourceOutput(
            context.CompilationProvider.Combine(providerForClasses.Collect()),
            (ctx, t) => this.GenerateNullObjectInPartialClass(ctx, t.Left, t.Right));
    }

    private void GenerateNullObjectInPartialClass(SourceProductionContext context, Compilation compilation,
        ImmutableArray<ClassNullObjectGeneratorArgs> args)
    {
        var nullObjectTypeInfoHandler = new NullObjectTypeInfoHandler(compilation);

        foreach (ClassNullObjectGeneratorArgs? arg in args)
        {
            ClassDeclarationSyntax classDeclaration = arg.ClassDeclarationSyntax;
            SemanticModel semanticModel = compilation.GetSemanticModel(classDeclaration.SyntaxTree);
            ISymbol? classSymbol =
                semanticModel.GetDeclaredSymbol(classDeclaration);

            bool makeNullableEnabled = compilation.Options.NullableContextOptions == NullableContextOptions.Enable;

            string namespaceName = classSymbol!.ContainingNamespace.ToDisplayString();
            string className = classSymbol.Name;

            if (classSymbol is ITypeSymbol ts)
            {
                ImmutableArray<INamedTypeSymbol> implementedInterfaces = ts.AllInterfaces;

                var location = arg.ClassDeclarationSyntax.GetLocation();
                string body = this.CreateBodyClassBody(context, location, arg.ClassDeclarationSyntax,
                    implementedInterfaces, compilation, nullObjectTypeInfoHandler);

                string code = $$"""
                                using System;
                                using System.CodeDom.Compiler;
                                using System.Runtime.CompilerServices;
                                using System.Threading.Tasks;

                                #nullable {{(makeNullableEnabled ? "enable" : "disable")}}

                                namespace {{namespaceName}};

                                [CompilerGenerated]
                                [GeneratedCode("ShadowWriter", "{{version}}")]
                                public sealed partial class {{className}}
                                {
                                  private {{className}}()
                                  {}

                                  public static {{classSymbol}} Instance { get; } = new {{className}}();

                                {{body.TrimEnd()}}
                                }
                                """;

                string cleanNamespace = namespaceName.Replace(".", "");
                context.AddSource($"{cleanNamespace}{className}.g.cs", SourceText.From(code, Encoding.UTF8));
            }
        }
    }

    /// <summary>
    ///     Generate code action.
    ///     It will be executed on specific nodes (ClassDeclarationSyntax annotated with the [Report] attribute) changed by the
    ///     user.
    /// </summary>
    /// <param name="context">Source generation context used to add source files.</param>
    /// <param name="compilation">Compilation used to provide access to the Semantic Model.</param>
    /// <param name="args">Nodes annotated with the [NullObject] attribute that trigger the generate action.</param>
    private void GenerateFullClassForInterface(SourceProductionContext context, Compilation compilation,
        ImmutableArray<InterfaceNullObjectGeneratorArgs> args)
    {
        static AttributeSyntax? GetAttributeByName(InterfaceDeclarationSyntax interfaceDeclaration,
            string attributeName)
        {
            return interfaceDeclaration.AttributeLists
                .SelectMany(list => list.Attributes)
                .FirstOrDefault(attr =>
                {
                    string name = attr.Name.ToString();
                    // Optional: Handling f√ºr Attribute mit oder ohne "Attribute"-Suffix
                    return name == attributeName || name == attributeName + "Attribute";
                });
        }

        var nullObjectTypeInfoHandler = new NullObjectTypeInfoHandler(compilation);

        foreach (InterfaceNullObjectGeneratorArgs? arg in args)
        {
            InterfaceDeclarationSyntax interfaceDeclaration = arg.InterfaceDeclarationSyntax;
            SemanticModel semanticModel = compilation.GetSemanticModel(interfaceDeclaration.SyntaxTree);
            if (semanticModel.GetDeclaredSymbol(interfaceDeclaration) is not INamedTypeSymbol interfaceSymbol)
            {
                continue;
            }

            string namespaceName = interfaceSymbol.ContainingNamespace.ToDisplayString();

            string interfaceName = interfaceSymbol.Name;
            string className = interfaceSymbol.Name;

            if (className.StartsWith("I", StringComparison.Ordinal))
            {
                className = className.Substring(1);
            }

            className = $"Null{className}";

            AttributeSyntax? attributeSyntax = GetAttributeByName(interfaceDeclaration, "ShadowWriter.ClassName");
            if (attributeSyntax?.ArgumentList?.Arguments.Count == 1)
            {
                AttributeArgumentSyntax x = attributeSyntax.ArgumentList.Arguments[0];

                className = x.Expression.ToString().Trim('"');
            }

            bool makeNullableEnabled = compilation.Options.NullableContextOptions == NullableContextOptions.Enable;

            string body = this.CreateBody(context, semanticModel, compilation, interfaceDeclaration,
                nullObjectTypeInfoHandler);

            string code = $$"""
                            using System;
                            using System.Threading.Tasks;
                            using System.CodeDom.Compiler;
                            using System.Runtime.CompilerServices;

                            #nullable {{(makeNullableEnabled ? "enable" : "disable")}}

                            namespace {{namespaceName}};

                            [CompilerGenerated]
                            [GeneratedCode("ShadowWriter", "{{version}}")]
                            public sealed partial class {{className}} : {{interfaceName}}
                            {
                              private {{className}}()
                              {}

                              public static {{interfaceName}} Instance { get; } = new {{className}}();

                              {{body}}
                            }
                            """;

            string cleanNamespace = namespaceName.Replace(".", "");

            context.AddSource($"{cleanNamespace}{className}.g.cs", SourceText.From(code, Encoding.UTF8));
        }
    }

    private string CreateBodyClassBody(SourceProductionContext context,
        Location location,
        ClassDeclarationSyntax classDeclarationSyntax,
        ImmutableArray<INamedTypeSymbol> implementedInterfaces,
        Compilation compilation, NullObjectTypeInfoHandler nullObjectTypeInfo)
    {
        IndentedStringBuilder codeBuilder = new("  ", 1);

        foreach (INamedTypeSymbol namedTypeSymbol in implementedInterfaces)
        {
            foreach (ISymbol member in namedTypeSymbol.GetMembers())
            {
                if (member is IPropertySymbol propertySymbol)
                {
                    if (propertySymbol.GetMethod is not null)
                    {
                        var typeInfo = nullObjectTypeInfo.GetTypeInfo(propertySymbol.Type);

                        if (!typeInfo.Supported)
                        {
                            // TODO check return Type

                            var ps = classDeclarationSyntax.Members.OfType<PropertyDeclarationSyntax>()
                                .FirstOrDefault(ps => ps.Identifier.ValueText == propertySymbol.Name);

                            if (ps is null)
                            {
                                var unsupportedType = Diagnostic.Create(
                                    this.unsupportedReturnTypeDescriptor,
                                    location,
                                    propertySymbol.Type.Name);

                                context.ReportDiagnostic(unsupportedType);
                            }


                            continue;
                        }


                        if (propertySymbol.SetMethod is null)
                        {
                            // Get only
                            codeBuilder.AppendLine(
                                $"public {propertySymbol.Type.ToDisplayString()} {propertySymbol.Name} => {typeInfo.ReturnValue};");
                        }
                        else
                        {
                            // Get and Set
                            codeBuilder.AppendLine(
                                $"public {propertySymbol.Type.ToDisplayString()} {propertySymbol.Name}");
                            codeBuilder.AppendLine("{");
                            codeBuilder.AppendLine($"get => {typeInfo.ReturnValue};");
                            codeBuilder.AppendLine("set => _ = value;");
                            codeBuilder.AppendLine("}");
                        }
                    }
                }
                else if (member is IMethodSymbol ms)
                {
                    if (ms.MethodKind == MethodKind.PropertyGet || ms.MethodKind == MethodKind.PropertySet)
                    {
                        continue;
                    }

                    List<string> parameters = GeneratorParameterList(ms);

                    codeBuilder.AppendLine($"// {ms.Name}");

                    string methodReturn = GenerateMethodReturn(nullObjectTypeInfo, ms);

                    bool isUnsupported = string.IsNullOrWhiteSpace(methodReturn);
                    if (isUnsupported)
                    {
                        // var semanticModel = compilation.GetSemanticModel(classDeclarationSyntax.SyntaxTree);

                        bool methodAlreadyImplemented = false;

                        var implementedMethods = classDeclarationSyntax.Members.OfType<MethodDeclarationSyntax>()
                            .Where(x => x.Identifier.ValueText == ms.Name).ToList();

                        if (implementedMethods.Count > 0)
                        {
                            foreach (var implementedMethod in implementedMethods)
                            {
                                if (ms.Parameters.Length != implementedMethod.ParameterList.Parameters.Count) continue;

                                // TODO check parameters for correct Type

                                var sm = compilation.GetSemanticModel(implementedMethod.SyntaxTree);
                                var si = sm.GetSymbolInfo(implementedMethod.ReturnType).Symbol as ITypeSymbol;

                                var isEqual = SymbolEqualityComparer.Default.Equals(si, ms.ReturnType);

                                if (isEqual)
                                {
                                    methodAlreadyImplemented = true;
                                    break;
                                }
                            }
                        }

                        if (!methodAlreadyImplemented)
                        {
                            var unsupportedType = Diagnostic.Create(
                                this.unsupportedReturnTypeDescriptor,
                                location,
                                ms.ReturnType.Name);

                            context.ReportDiagnostic(unsupportedType);
                        }

                        continue;
                    }

                    codeBuilder.Append("public ");


                    codeBuilder.Append(ms.ReturnType.ToDisplayString());
                    codeBuilder.Append(" ");
                    codeBuilder.Append(member.Name);
                    codeBuilder.Append("(");
                    codeBuilder.Append(string.Join(", ", parameters));
                    codeBuilder.Append(")");

                    if (!string.IsNullOrWhiteSpace(methodReturn))
                    {
                        codeBuilder.AppendLine();
                        codeBuilder.AppendLine(methodReturn);
                    }
                    else
                    {
                        codeBuilder.AppendLine(";");
                    }
                }
            }
        }

        return codeBuilder.ToString();
    }

    private string CreateBody(SourceProductionContext context, SemanticModel semanticModel, Compilation compilation,
        InterfaceDeclarationSyntax interfaceDeclaration, NullObjectTypeInfoHandler nullObjectTypeInfoHandler)
    {
        IndentedStringBuilder sb = new("  ", 1);

        foreach (MemberDeclarationSyntax method in interfaceDeclaration.Members)
        {
            ISymbol? ds = semanticModel.GetDeclaredSymbol(method);

            if (ds is IMethodSymbol ms)
            {
                List<string> parameters = GeneratorParameterList(ms);

                string result = GenerateMethodReturn(nullObjectTypeInfoHandler, ms);

                if (string.IsNullOrWhiteSpace(result))
                {
                    sb.Append(
                            $"public partial {ms.ReturnType.ToDisplayString()} {ms.Name}({string.Join(", ", parameters)});")
                        .AppendLine();
                }
                else
                {
                    sb.Append($"public {ms.ReturnType.ToDisplayString()} {ms.Name}({string.Join(", ", parameters)})")
                        .AppendLine();
                    sb.AppendLine(result);
                }
            }

            if (ds is IPropertySymbol property)
            {
                if (property.GetMethod is not null && property.SetMethod is null)
                {
                    sb.AppendLine($"public {property.Type.ToDisplayString()} {property.Name} => default;");
                }
                else if (property.SetMethod is not null && property.GetMethod is not null)
                {
                    sb.AppendLine($"public {property.Type.ToDisplayString()} {property.Name}");
                    sb.AppendLine("{");
                    sb.AppendLine("get => default;");
                    sb.AppendLine("set => _ = value;");
                    sb.AppendLine("}");
                }
            }

            sb.AppendLine();
        }

        return sb.ToString();
    }

    private static List<string> GeneratorParameterList(IMethodSymbol ms)
    {
        List<string> parameters = new();

        foreach (IParameterSymbol? parameterSymbol in ms.Parameters)
        {
            parameters.Add($"{parameterSymbol.Type.ToDisplayString()} {parameterSymbol.Name}");
        }

        return parameters;
    }

    private string GenerateMethodReturn(NullObjectTypeInfoHandler nullObjectTypeInfo, IMethodSymbol ms)
    {
        if (ms.ReturnsVoid)
        {
            return "{ }";
        }

        var typeInfo = nullObjectTypeInfo.GetTypeInfo(ms.ReturnType);

        if (typeInfo.Supported)
        {
            if (typeInfo.IncludeReturn)
            {
                return $$"""
                         {
                            return {{typeInfo.ReturnValue}};
                         }
                         """;
            }
            else
            {
                return $$"""
                         {
                            {{typeInfo.ReturnValue}};
                         }
                         """;
            }


        }

        return string.Empty;
    }


    /// <summary>
    ///     Checks whether the Node is annotated with the [Report] attribute and maps syntax context to the specific node type
    ///     (ClassDeclarationSyntax).
    /// </summary>
    /// <param name="context">Syntax context, based on CreateSyntaxProvider predicate</param>
    /// <returns>The specific cast and whether the attribute was found.</returns>
    private static InterfaceNullObjectGeneratorArgs GetInterfaceDeclarationForSourceGen(
        GeneratorSyntaxContext context)
    {
        InterfaceDeclarationSyntax classDeclarationSyntax = (InterfaceDeclarationSyntax)context.Node;

        // Go through all attributes of the class.
        foreach (AttributeListSyntax attributeListSyntax in classDeclarationSyntax.AttributeLists)
        {
            foreach (AttributeSyntax attributeSyntax in attributeListSyntax.Attributes)
            {
                if (context.SemanticModel.GetSymbolInfo(attributeSyntax).Symbol is not IMethodSymbol attributeSymbol)
                {
                    continue; // if we can't get the symbol, ignore it
                }

                string attributeName = attributeSymbol.ContainingType.ToDisplayString();

                // Check the full name of the [Report] attribute.
                if (attributeName == $"{Namespace}.{NullObjectAttributeName}")
                {
                    return new InterfaceNullObjectGeneratorArgs(true, classDeclarationSyntax);
                }
            }
        }

        return new InterfaceNullObjectGeneratorArgs(false, classDeclarationSyntax);
    }


    /// <summary>
    ///     Checks whether the Node is annotated with the [Report] attribute and maps syntax context to the specific node type
    ///     (ClassDeclarationSyntax).
    /// </summary>
    /// <param name="context">Syntax context, based on CreateSyntaxProvider predicate</param>
    /// <returns>The specific cast and whether the attribute was found.</returns>
    private static ClassNullObjectGeneratorArgs GetClassDeclarationForSourceGen(
        GeneratorSyntaxContext context)
    {
        ClassDeclarationSyntax classDeclarationSyntax = (ClassDeclarationSyntax)context.Node;

        // Go through all attributes of the class.
        foreach (AttributeListSyntax attributeListSyntax in classDeclarationSyntax.AttributeLists)
        {
            foreach (AttributeSyntax attributeSyntax in attributeListSyntax.Attributes)
            {
                if (context.SemanticModel.GetSymbolInfo(attributeSyntax).Symbol is not IMethodSymbol attributeSymbol)
                {
                    continue; // if we can't get the symbol, ignore it
                }

                string attributeName = attributeSymbol.ContainingType.ToDisplayString();

                // Check the full name of the [Report] attribute.
                if (attributeName == $"{Namespace}.{NullObjectAttributeName}")
                {
                    return new ClassNullObjectGeneratorArgs(true, classDeclarationSyntax);
                }
            }
        }

        return new ClassNullObjectGeneratorArgs(false, classDeclarationSyntax);
    }
}