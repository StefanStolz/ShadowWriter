using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace ShadowWriter;

[Generator]
public sealed class NullObjectGenerator : IIncrementalGenerator {
    private const string Namespace = "ShadowWriter";
    private const string NullObjectAttributeName = "NullObjectAttribute";
    private const string ClassNameAttributeName = "ClassNameAttribute";

    private const string AttributeSourceCode = $@"// <auto-generated/>

using System;

namespace {Namespace}
{{
    [System.AttributeUsage(AttributeTargets.Interface | AttributeTargets.Class)]
    internal sealed class {NullObjectAttributeName} : System.Attribute
    {{

    }}

    [System.AttributeUsage(System.AttributeTargets.Interface)]
    public sealed class {ClassNameAttributeName} : System.Attribute
    {{
        public string Name {{ get; }}

        public {ClassNameAttributeName}(string name)
        {{
            this.Name = name;
        }}

        public {ClassNameAttributeName}()
        {{
            this.Name = string.Empty;
        }}
    }}
}}";

    public void Initialize(IncrementalGeneratorInitializationContext context) {
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
            "NullObjectAttribute.g.cs",
            SourceText.From(AttributeSourceCode, Encoding.UTF8)));

        IncrementalValuesProvider<InterfaceNullObjectGeneratorArgs> providerForInterfaces = context.SyntaxProvider
                                                                                                   .CreateSyntaxProvider(
                                                                                                       (s, _) => s is InterfaceDeclarationSyntax,
                                                                                                       (ctx, _) => GetInterfaceDeclarationForSourceGen(ctx))
                                                                                                   .Where(t => t.ReportAttributeFound)
                                                                                                   .Select((t, _) => t);

        IncrementalValuesProvider<ClassNullObjectGeneratorArgs> providerForClasses = context.SyntaxProvider
                                                                                            .CreateSyntaxProvider(
                                                                                                (s, _) => s is ClassDeclarationSyntax,
                                                                                                (ctx, _) => GetClassDeclarationForSourceGen(ctx))
                                                                                            .Where(t => t.ReportAttributeFound)
                                                                                            .Select((t, _) => t);

        // Generate the source code.
        context.RegisterSourceOutput(
            context.CompilationProvider.Combine(providerForInterfaces.Collect()),
            (ctx, t) => this.GenerateCode(ctx, t.Left, t.Right));


        context.RegisterSourceOutput(
            context.CompilationProvider.Combine(providerForClasses.Collect()),
            (ctx, t) => this.GenerateCode(ctx, t.Left, t.Right));
    }

    private void GenerateCode(SourceProductionContext context, Compilation compilation,
        ImmutableArray<ClassNullObjectGeneratorArgs> args) {
        foreach (ClassNullObjectGeneratorArgs? arg in args) {
            ClassDeclarationSyntax classDeclaration = arg.ClassDeclarationSyntax;
            SyntaxTree tree = classDeclaration.SyntaxTree;
            SyntaxNode root = tree.GetRoot();
            SemanticModel semanticModel = compilation.GetSemanticModel(classDeclaration.SyntaxTree);
            ISymbol? classSymbol = semanticModel.GetDeclaredSymbol(root.DescendantNodes().OfType<ClassDeclarationSyntax>().First());

            bool makeNullableEnabled = compilation.Options.NullableContextOptions == NullableContextOptions.Enable;

            string namespaceName = classSymbol!.ContainingNamespace.ToDisplayString();
            string className = classSymbol.Name;

            if (classSymbol is ITypeSymbol ts) {
                ImmutableArray<INamedTypeSymbol> implementedInterfaces = ts.AllInterfaces;


                string body = this.CreateBodyClassBody(implementedInterfaces, compilation, classSymbol);


                string code = $$"""
                                using System;
                                using System.Threading.Tasks;

                                #nullable {{(makeNullableEnabled ? "enable" : "disable")}}

                                namespace {{namespaceName}};

                                public sealed partial class {{className}}
                                {
                                  private {{className}}()
                                  {}

                                  public static {{classSymbol}} Instance { get; } = new {{className}}();

                                {{body}}
                                }
                                """;

                string cleanNamespace = namespaceName.Replace(".", "");
                context.AddSource($"{cleanNamespace}{className}.g.cs", SourceText.From(code, Encoding.UTF8));
            }
        }
    }

    /// <summary>
    ///     Generate code action.
    ///     It will be executed on specific nodes (ClassDeclarationSyntax annotated with the [Report] attribute) changed by the
    ///     user.
    /// </summary>
    /// <param name="context">Source generation context used to add source files.</param>
    /// <param name="compilation">Compilation used to provide access to the Semantic Model.</param>
    /// <param name="args">Nodes annotated with the [NullObject] attribute that trigger the generate action.</param>
    private void GenerateCode(SourceProductionContext context, Compilation compilation,
        ImmutableArray<InterfaceNullObjectGeneratorArgs> args) {
        static AttributeSyntax? GetAttributeByName(InterfaceDeclarationSyntax interfaceDeclaration, string attributeName) {
            return interfaceDeclaration.AttributeLists
                                       .SelectMany(list => list.Attributes)
                                       .FirstOrDefault(attr => {
                                           string name = attr.Name.ToString();
                                           // Optional: Handling f√ºr Attribute mit oder ohne "Attribute"-Suffix
                                           return name == attributeName || name == attributeName + "Attribute";
                                       });
        }


        foreach (InterfaceNullObjectGeneratorArgs? arg in args) {
            InterfaceDeclarationSyntax interfaceDeclaration = arg.InterfaceDeclarationSyntax;
            SemanticModel semanticModel = compilation.GetSemanticModel(interfaceDeclaration.SyntaxTree);
            if (semanticModel.GetDeclaredSymbol(interfaceDeclaration) is not INamedTypeSymbol interfaceSymbol) {
                continue;
            }

            string namespaceName = interfaceSymbol.ContainingNamespace.ToDisplayString();

            string interfaceName = interfaceSymbol.Name;
            string className = interfaceSymbol.Name;

            if (className.StartsWith("I", StringComparison.Ordinal)) {
                className = className.Substring(1);
            }

            className = $"Null{className}";

            AttributeSyntax? attributeSyntax = GetAttributeByName(interfaceDeclaration, "ShadowWriter.ClassName");
            if (attributeSyntax?.ArgumentList?.Arguments.Count == 1) {
                AttributeArgumentSyntax x = attributeSyntax.ArgumentList.Arguments[0];

                className = x.Expression.ToString().Trim('"');
            }

            bool makeNullableEnabled = compilation.Options.NullableContextOptions == NullableContextOptions.Enable;

            string body = this.CreateBody(semanticModel, compilation, interfaceSymbol, interfaceDeclaration);

            string code = $$"""
                            using System;
                            using System.Threading.Tasks;

                            #nullable {{(makeNullableEnabled ? "enable" : "disable")}}

                            namespace {{namespaceName}};

                            public sealed partial class {{className}} : {{interfaceName}}
                            {
                              private {{className}}()
                              {}

                              public static {{interfaceName}} Instance { get; } = new {{className}}();

                            {{body}}
                            }
                            """;

            string cleanNamespace = namespaceName.Replace(".", "");

            context.AddSource($"{cleanNamespace}{className}.g.cs", SourceText.From(code, Encoding.UTF8));
        }
    }

    private string CreateBodyClassBody(ImmutableArray<INamedTypeSymbol> implementedInterfaces, Compilation compilation, ISymbol classSymbol) {
        StringBuilder codeBuilder = new();

        foreach (INamedTypeSymbol namedTypeSymbol in implementedInterfaces) {
            foreach (ISymbol member in namedTypeSymbol.GetMembers()) {
                if (member is IMethodSymbol ms) {
                    string x = member.Name;

                    List<string> parameters = GeneratorParameterList(ms);

                    codeBuilder.AppendLine($"// {x}");

                    codeBuilder.Append("public ");
                    codeBuilder.Append(ms.ReturnType.ToDisplayString());
                    codeBuilder.Append(" ");
                    codeBuilder.Append(member.Name);
                    codeBuilder.Append("(");
                    codeBuilder.Append(string.Join(", ", parameters));
                    codeBuilder.Append(")");
                    codeBuilder.AppendLine();
                    codeBuilder.AppendLine(GenerateMethodReturn(compilation, ms));
                }
            }
        }

        return codeBuilder.ToString();
    }

    private string CreateBody(SemanticModel semanticModel, Compilation compilation, INamedTypeSymbol interfaceSymbol, InterfaceDeclarationSyntax interfaceDeclaration) {
        StringBuilder sb = new();

        foreach (MemberDeclarationSyntax method in interfaceDeclaration.Members) {
            ISymbol? ds = semanticModel.GetDeclaredSymbol(method);

            if (ds is IMethodSymbol ms) {
                List<string> parameters = GeneratorParameterList(ms);

                string result = GenerateMethodReturn(compilation, ms);


                if (string.IsNullOrWhiteSpace(result)) {
                    sb.Append($"public partial {ms.ReturnType.ToDisplayString()} {ms.Name}({string.Join(", ", parameters)});").AppendLine();
                }
                else {
                    sb.Append($"public {ms.ReturnType.ToDisplayString()} {ms.Name}({string.Join(", ", parameters)})").AppendLine();
                    sb.AppendLine(result);
                }
            }

            if (ds is IPropertySymbol property) {
                if (property.GetMethod is not null && property.SetMethod is null) {
                    sb.AppendLine($"public {property.Type.ToDisplayString()} {property.Name} => default;");
                }
                else if (property.SetMethod is not null && property.GetMethod is not null) {
                    sb.AppendLine($"public {property.Type.ToDisplayString()} {property.Name}");
                    sb.AppendLine("{");
                    sb.AppendLine("get => default;");
                    sb.AppendLine("set => _ = value;");
                    sb.AppendLine("}");
                }
            }

            sb.AppendLine();
        }

        return sb.ToString();
    }

    private static List<string> GeneratorParameterList(IMethodSymbol ms) {
        List<string> parameters = new();

        foreach (IParameterSymbol? parameterSymbol in ms.Parameters) {
            parameters.Add($"{parameterSymbol.Type.ToDisplayString()} {parameterSymbol.Name}");
        }

        return parameters;
    }

    private static string GenerateMethodReturn(Compilation compilation, IMethodSymbol ms) {
        string result = string.Empty;

        if (ms.ReturnsVoid) {
            result = "{ }";
        }
        else if (IsValueTask(ms.ReturnType)) {
            result = """
                     {
                        return ValueTask.CompletedTask;
                     }
                     """;
        }
        else if (ms.ReturnType.IsValueType) {
            result = """
                     {
                       return default;
                     }
                     """;
        }
        else if (IsIEnumerableOfT(ms.ReturnType)) {
            result = """
                     {
                        yield break;
                     }
                     """;
        }
        else if (IsTask(ms.ReturnType)) {
            result = """
                     {
                        return Task.CompletedTask;
                     }
                     """;
        }

        return result;

        bool IsValueTask(ITypeSymbol typeSymbol) {
            INamedTypeSymbol? taskType = compilation.GetTypeByMetadataName("System.Threading.Tasks.ValueTask");

            return SymbolEqualityComparer.Default.Equals(typeSymbol, taskType);
        }

        bool IsIEnumerableOfT(ITypeSymbol typeSymbol) {
            if (typeSymbol is INamedTypeSymbol namedTypeSymbol) {
                return namedTypeSymbol.ConstructedFrom.SpecialType == SpecialType.System_Collections_Generic_IEnumerable_T;
            }

            return false;
        }

        bool IsTask(ITypeSymbol typeSymbol) {
            INamedTypeSymbol? taskType = compilation.GetTypeByMetadataName("System.Threading.Tasks.Task");

            return SymbolEqualityComparer.Default.Equals(typeSymbol, taskType);
        }
    }


    /// <summary>
    ///     Checks whether the Node is annotated with the [Report] attribute and maps syntax context to the specific node type
    ///     (ClassDeclarationSyntax).
    /// </summary>
    /// <param name="context">Syntax context, based on CreateSyntaxProvider predicate</param>
    /// <returns>The specific cast and whether the attribute was found.</returns>
    private static InterfaceNullObjectGeneratorArgs GetInterfaceDeclarationForSourceGen(
        GeneratorSyntaxContext context) {
        InterfaceDeclarationSyntax classDeclarationSyntax = (InterfaceDeclarationSyntax)context.Node;

        // Go through all attributes of the class.
        foreach (AttributeListSyntax attributeListSyntax in classDeclarationSyntax.AttributeLists) {
            foreach (AttributeSyntax attributeSyntax in attributeListSyntax.Attributes) {
                if (context.SemanticModel.GetSymbolInfo(attributeSyntax).Symbol is not IMethodSymbol attributeSymbol) {
                    continue; // if we can't get the symbol, ignore it
                }

                string attributeName = attributeSymbol.ContainingType.ToDisplayString();

                string? className = null;

                if (attributeSyntax.ArgumentList?.Arguments.Count == 1) {
                    AttributeArgumentSyntax x = attributeSyntax.ArgumentList.Arguments[0];

                    className = x.Expression.ToString().Trim('"');
                }


                // Check the full name of the [Report] attribute.
                if (attributeName == $"{Namespace}.{NullObjectAttributeName}") {
                    return new InterfaceNullObjectGeneratorArgs(true, classDeclarationSyntax);
                }
            }
        }

        return new InterfaceNullObjectGeneratorArgs(false, classDeclarationSyntax);
    }


    /// <summary>
    ///     Checks whether the Node is annotated with the [Report] attribute and maps syntax context to the specific node type
    ///     (ClassDeclarationSyntax).
    /// </summary>
    /// <param name="context">Syntax context, based on CreateSyntaxProvider predicate</param>
    /// <returns>The specific cast and whether the attribute was found.</returns>
    private static ClassNullObjectGeneratorArgs GetClassDeclarationForSourceGen(
        GeneratorSyntaxContext context) {
        ClassDeclarationSyntax classDeclarationSyntax = (ClassDeclarationSyntax)context.Node;

        // Go through all attributes of the class.
        foreach (AttributeListSyntax attributeListSyntax in classDeclarationSyntax.AttributeLists) {
            foreach (AttributeSyntax attributeSyntax in attributeListSyntax.Attributes) {
                if (context.SemanticModel.GetSymbolInfo(attributeSyntax).Symbol is not IMethodSymbol attributeSymbol) {
                    continue; // if we can't get the symbol, ignore it
                }

                string attributeName = attributeSymbol.ContainingType.ToDisplayString();

                // Check the full name of the [Report] attribute.
                if (attributeName == $"{Namespace}.{NullObjectAttributeName}") {
                    return new ClassNullObjectGeneratorArgs(true, classDeclarationSyntax);
                }
            }
        }

        return new ClassNullObjectGeneratorArgs(false, classDeclarationSyntax);
    }
}