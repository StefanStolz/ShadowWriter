using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Reflection;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace ShadowWriter.NullObject;

[Generator]
public sealed class NullObjectGenerator : IIncrementalGenerator
{
    private readonly DiagnosticDescriptor unsupportedReturnTypeDescriptor = new DiagnosticDescriptor(
        id: "SHADOWWRITER0001",
        title: "Unsupported return type",
        messageFormat:
        "Unsupported return type '{0}'. This type is not handled by the source generator. Please provide a manual implementation.",
        category: nameof(NullObjectGenerator),
        defaultSeverity: DiagnosticSeverity.Error,
        isEnabledByDefault: true
    );

    private const string Namespace = "ShadowWriter";
    private const string NullObjectAttributeName = "NullObjectAttribute";
    private const string ClassNameAttributeName = "ClassNameAttribute";

    private readonly string version = "0.0.0";

    private string AttributeSourceCode => $@"// <auto-generated/>

using System;
using System.CodeDom.Compiler;
using System.Runtime.CompilerServices;

namespace {Namespace}
{{
    [CompilerGenerated]
    [GeneratedCode(""ShadowWriter"", ""{this.version}"")]
    [System.AttributeUsage(AttributeTargets.Interface | AttributeTargets.Class)]
    internal sealed class {NullObjectAttributeName} : System.Attribute
    {{

    }}

    [CompilerGenerated]
    [GeneratedCode(""ShadowWriter"", ""{this.version}"")]
    [System.AttributeUsage(System.AttributeTargets.Interface)]
    internal sealed class {ClassNameAttributeName} : System.Attribute
    {{
        public string Name {{ get; }}

        public {ClassNameAttributeName}(string name)
        {{
            this.Name = name;
        }}

        public {ClassNameAttributeName}()
        {{
            this.Name = string.Empty;
        }}
    }}
}}";

    public NullObjectGenerator()
    {
        var versionAttribute = this.GetType().Assembly.GetCustomAttribute<AssemblyFileVersionAttribute>();
        if (versionAttribute != null)
        {
            this.version = versionAttribute.Version;
        }
    }

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
            "NullObjectAttribute.g.cs",
            SourceText.From(this.AttributeSourceCode, Encoding.UTF8)));

        IncrementalValuesProvider<InterfaceNullObjectGeneratorArgs> providerForInterfaces
            = context.SyntaxProvider
                .CreateSyntaxProvider(
                    (s, _) => s is InterfaceDeclarationSyntax,
                    (ctx, _) => GetInterfaceDeclarationForSourceGen(ctx))
                .Where(t => t.NullObjectAttributeFound)
                .Select((t, _) => t);

        IncrementalValuesProvider<ClassNullObjectGeneratorArgs> providerForClasses
            = context.SyntaxProvider
                .CreateSyntaxProvider(
                    (s, _) => s is ClassDeclarationSyntax,
                    (ctx, _) => GetClassDeclarationForSourceGen(ctx))
                .Where(t => t.NullObjectAttributeFound)
                .Select((t, _) => t);

        context.RegisterSourceOutput(
            context.CompilationProvider.Combine(providerForInterfaces.Collect()),
            (ctx, t) => this.GenerateFullClassForInterface(ctx, t.Left, t.Right));

        context.RegisterSourceOutput(
            context.CompilationProvider.Combine(providerForClasses.Collect()),
            (ctx, t) => this.GenerateNullObjectInPartialClass(ctx, t.Left, t.Right));
    }

    private void GenerateNullObjectInPartialClass(SourceProductionContext context, Compilation compilation,
        ImmutableArray<ClassNullObjectGeneratorArgs> args)
    {
        var generateNullObjectInPartialClass =
            new GenerateNullObjectInPartialClass(this.version, this.unsupportedReturnTypeDescriptor, compilation);

        generateNullObjectInPartialClass.Execute(context,
            args.Where(a => a.NullObjectAttributeFound).Select(a => a.ClassDeclarationSyntax));
    }

    /// <summary>
    ///     Generate code action.
    ///     It will be executed on specific nodes (ClassDeclarationSyntax annotated with the [Report] attribute) changed by the
    ///     user.
    /// </summary>
    /// <param name="context">Source generation context used to add source files.</param>
    /// <param name="compilation">Compilation used to provide access to the Semantic Model.</param>
    /// <param name="args">Nodes annotated with the [NullObject] attribute that trigger the generate action.</param>
    private void GenerateFullClassForInterface(SourceProductionContext context, Compilation compilation,
        ImmutableArray<InterfaceNullObjectGeneratorArgs> args)
    {
        static AttributeSyntax? GetAttributeByName(InterfaceDeclarationSyntax interfaceDeclaration,
            string attributeName)
        {
            return interfaceDeclaration.AttributeLists
                .SelectMany(list => list.Attributes)
                .FirstOrDefault(attr =>
                {
                    string name = attr.Name.ToString();
                    // Optional: Handling f√ºr Attribute mit oder ohne "Attribute"-Suffix
                    return name == attributeName || name == attributeName + "Attribute";
                });
        }

        var nullObjectTypeInfoHandler = new NullObjectTypeInfoHandler(compilation);

        foreach (InterfaceNullObjectGeneratorArgs? arg in args)
        {
            InterfaceDeclarationSyntax interfaceDeclaration = arg.InterfaceDeclarationSyntax;
            SemanticModel semanticModel = compilation.GetSemanticModel(interfaceDeclaration.SyntaxTree);
            if (semanticModel.GetDeclaredSymbol(interfaceDeclaration) is not INamedTypeSymbol interfaceSymbol)
            {
                continue;
            }

            string namespaceName = interfaceSymbol.ContainingNamespace.ToDisplayString();

            string interfaceName = interfaceSymbol.Name;
            string className = interfaceSymbol.Name;

            if (className.StartsWith("I", StringComparison.Ordinal))
            {
                className = className.Substring(1);
            }

            className = $"Null{className}";

            AttributeSyntax? attributeSyntax = GetAttributeByName(interfaceDeclaration, "ShadowWriter.ClassName");
            if (attributeSyntax?.ArgumentList?.Arguments.Count == 1)
            {
                AttributeArgumentSyntax x = attributeSyntax.ArgumentList.Arguments[0];

                className = x.Expression.ToString().Trim('"');
            }

            bool makeNullableEnabled = compilation.Options.NullableContextOptions == NullableContextOptions.Enable;

            string body = this.CreateBody(semanticModel, interfaceDeclaration,
                nullObjectTypeInfoHandler);

            string code = $$"""
                            using System;
                            using System.Linq;
                            using System.Threading.Tasks;
                            using System.CodeDom.Compiler;
                            using System.Runtime.CompilerServices;

                            // Generated by {{nameof(GenerateFullClassForInterface)}}

                            #nullable {{(makeNullableEnabled ? "enable" : "disable")}}

                            namespace {{namespaceName}};

                            [CompilerGenerated]
                            [GeneratedCode("ShadowWriter", "{{this.version}}")]
                            public sealed partial class {{className}} : {{interfaceName}}
                            {
                              private {{className}}()
                              {}

                              public static {{interfaceName}} Instance { get; } = new {{className}}();

                              {{body}}
                            }
                            """;

            string cleanNamespace = namespaceName.Replace(".", "");

            context.AddSource($"{cleanNamespace}{className}.g.cs", SourceText.From(code, Encoding.UTF8));
        }
    }


    private string CreateBody(SemanticModel semanticModel,
        InterfaceDeclarationSyntax interfaceDeclaration, NullObjectTypeInfoHandler nullObjectTypeInfoHandler)
    {
        IndentedStringBuilder sb = new("  ", 1);

        foreach (MemberDeclarationSyntax method in interfaceDeclaration.Members)
        {
            ISymbol? ds = semanticModel.GetDeclaredSymbol(method);

            if (ds is IMethodSymbol ms)
            {
                List<string> parameters = GeneratorParameterList(ms);

                string result = this.GenerateMethodReturn(nullObjectTypeInfoHandler, ms);

                if (string.IsNullOrWhiteSpace(result))
                {
                    sb.Append(
                            $"public partial {ms.ReturnType.ToDisplayString()} {ms.Name}({string.Join(", ", parameters)});")
                        .AppendLine();
                }
                else
                {
                    sb.Append($"public {ms.ReturnType.ToDisplayString()} {ms.Name}({string.Join(", ", parameters)})")
                        .AppendLine();
                    sb.AppendLine(result);
                }
            }

            if (ds is IPropertySymbol property)
            {
                if (property.GetMethod is not null && property.SetMethod is null)
                {
                    sb.AppendLine($"public {property.Type.ToDisplayString()} {property.Name} => default;");
                }
                else if (property.SetMethod is not null && property.GetMethod is not null)
                {
                    sb.AppendLine($"public {property.Type.ToDisplayString()} {property.Name}");
                    sb.AppendLine("{");
                    sb.AppendLine("get => default;");
                    sb.AppendLine("set => _ = value;");
                    sb.AppendLine("}");
                }
            }

            sb.AppendLine();
        }

        return sb.ToString();
    }

    private static List<string> GeneratorParameterList(IMethodSymbol ms)
    {
        List<string> parameters = new();

        foreach (IParameterSymbol? parameterSymbol in ms.Parameters)
        {
            parameters.Add($"{parameterSymbol.Type.ToDisplayString()} {parameterSymbol.Name}");
        }

        return parameters;
    }

    private string GenerateMethodReturn(NullObjectTypeInfoHandler nullObjectTypeInfo, IMethodSymbol ms)
    {
        if (ms.ReturnsVoid)
        {
            return "{ }";
        }

        var typeInfo = nullObjectTypeInfo.GetTypeInfo(ms.ReturnType);

        if (typeInfo.Supported)
        {
            if (typeInfo.IncludeReturn)
            {
                return $$"""
                         {
                            return {{typeInfo.ReturnValue}};
                         }
                         """;
            }
            else
            {
                return $$"""
                         {
                            {{typeInfo.ReturnValue}};
                         }
                         """;
            }
        }

        return string.Empty;
    }


    /// <summary>
    ///     Checks whether the Node is annotated with the [Report] attribute and maps syntax context to the specific node type
    ///     (ClassDeclarationSyntax).
    /// </summary>
    /// <param name="context">Syntax context, based on CreateSyntaxProvider predicate</param>
    /// <returns>The specific cast and whether the attribute was found.</returns>
    private static InterfaceNullObjectGeneratorArgs GetInterfaceDeclarationForSourceGen(
        GeneratorSyntaxContext context)
    {
        InterfaceDeclarationSyntax classDeclarationSyntax = (InterfaceDeclarationSyntax)context.Node;

        // Go through all attributes of the class.
        foreach (AttributeListSyntax attributeListSyntax in classDeclarationSyntax.AttributeLists)
        {
            foreach (AttributeSyntax attributeSyntax in attributeListSyntax.Attributes)
            {
                if (context.SemanticModel.GetSymbolInfo(attributeSyntax).Symbol is not IMethodSymbol attributeSymbol)
                {
                    continue; // if we can't get the symbol, ignore it
                }

                string attributeName = attributeSymbol.ContainingType.ToDisplayString();

                // Check the full name of the [Report] attribute.
                if (attributeName == $"{Namespace}.{NullObjectAttributeName}")
                {
                    return new InterfaceNullObjectGeneratorArgs(true, classDeclarationSyntax);
                }
            }
        }

        return new InterfaceNullObjectGeneratorArgs(false, classDeclarationSyntax);
    }


    /// <summary>
    ///     Checks whether the Node is annotated with the [Report] attribute and maps syntax context to the specific node type
    ///     (ClassDeclarationSyntax).
    /// </summary>
    /// <param name="context">Syntax context, based on CreateSyntaxProvider predicate</param>
    /// <returns>The specific cast and whether the attribute was found.</returns>
    private static ClassNullObjectGeneratorArgs GetClassDeclarationForSourceGen(
        GeneratorSyntaxContext context)
    {
        ClassDeclarationSyntax classDeclarationSyntax = (ClassDeclarationSyntax)context.Node;

        // Go through all attributes of the class.
        foreach (AttributeListSyntax attributeListSyntax in classDeclarationSyntax.AttributeLists)
        {
            foreach (AttributeSyntax attributeSyntax in attributeListSyntax.Attributes)
            {
                if (context.SemanticModel.GetSymbolInfo(attributeSyntax).Symbol is not IMethodSymbol attributeSymbol)
                {
                    continue; // if we can't get the symbol, ignore it
                }

                string attributeName = attributeSymbol.ContainingType.ToDisplayString();

                // Check the full name of the [Report] attribute.
                if (attributeName == $"{Namespace}.{NullObjectAttributeName}")
                {
                    return new ClassNullObjectGeneratorArgs(true, classDeclarationSyntax);
                }
            }
        }

        return new ClassNullObjectGeneratorArgs(false, classDeclarationSyntax);
    }
}