using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace ShadowWriter.NullObject;

public sealed class GenerateNullObjectInPartialClass
{
    private readonly string version;
    private readonly DiagnosticDescriptor unsupportedReturnTypeDescriptor;
    private readonly Compilation compilation;
    private readonly NullObjectTypeInfoHandler nullObjectTypeInfoHandler;
    private readonly SyntaxHelper syntaxHelper;

    public GenerateNullObjectInPartialClass(string version, DiagnosticDescriptor unsupportedReturnTypeDescriptor,
        Compilation compilation)
    {
        this.version = version;
        this.unsupportedReturnTypeDescriptor = unsupportedReturnTypeDescriptor;
        this.compilation = compilation;
        this.nullObjectTypeInfoHandler = new NullObjectTypeInfoHandler(this.compilation);
        this.syntaxHelper = new SyntaxHelper(this.compilation);
    }

    public void Execute(SourceProductionContext context, IEnumerable<ClassDeclarationSyntax> classDeclarations)
    {
        foreach (var classDeclaration in classDeclarations)
        {
            SemanticModel semanticModel = compilation.GetSemanticModel(classDeclaration.SyntaxTree);
            ISymbol? classSymbol =
                semanticModel.GetDeclaredSymbol(classDeclaration);

            if (classSymbol is not ITypeSymbol typeSymbol)
            {
                continue;
            }

            bool makeNullableEnabled = compilation.Options.NullableContextOptions == NullableContextOptions.Enable;

            string namespaceName = typeSymbol.ContainingNamespace.ToDisplayString();
            string className = typeSymbol.Name;

            ImmutableArray<INamedTypeSymbol> implementedInterfaces = typeSymbol.AllInterfaces;

            var location = classDeclaration.GetLocation();
            string body = this.CreateBodyClassBody(context, location, classDeclaration,
                implementedInterfaces);

            string code = $$"""
                            using System;
                            using System.Linq;
                            using System.CodeDom.Compiler;
                            using System.Runtime.CompilerServices;
                            using System.Threading.Tasks;

                            // Generated by {{nameof(GenerateNullObjectInPartialClass)}}

                            #nullable {{(makeNullableEnabled ? "enable" : "disable")}}

                            namespace {{namespaceName}};

                            [CompilerGenerated]
                            [GeneratedCode("ShadowWriter", "{{this.version}}")]
                            public sealed partial class {{className}}
                            {
                              private {{className}}()
                              {}

                              public static {{classSymbol}} Instance { get; } = new {{className}}();

                            {{body.TrimEnd()}}
                            }
                            """;

            string cleanNamespace = namespaceName.Replace(".", "");
            context.AddSource($"{cleanNamespace}{className}.g.cs", SourceText.From(code, Encoding.UTF8));
        }
    }

    private string CreateBodyClassBody(SourceProductionContext context,
        Location location,
        ClassDeclarationSyntax classDeclarationSyntax,
        ImmutableArray<INamedTypeSymbol> implementedInterfaces)
    {
        IndentedStringBuilder codeBuilder = new("  ", 1);

        foreach (ISymbol member in implementedInterfaces.SelectMany(ii => ii.GetMembers()))
        {
            switch (member)
            {
                case IPropertySymbol propertySymbol:
                    this.GeneratePropertyCode(context, location, classDeclarationSyntax, propertySymbol, codeBuilder);
                    break;
                case IMethodSymbol { MethodKind: MethodKind.PropertyGet or MethodKind.PropertySet }:
                    continue;
                case IMethodSymbol methodSymbol:
                    this.GenerateMethodCode(context, location, classDeclarationSyntax, methodSymbol, codeBuilder);
                    break;
            }
        }

        return codeBuilder.ToString();
    }

    private void GenerateMethodCode(SourceProductionContext context, Location location,
        ClassDeclarationSyntax classDeclarationSyntax, IMethodSymbol methodSymbol, IndentedStringBuilder codeBuilder)
    {
        List<string> parameters = GeneratorParameterList(methodSymbol);

        codeBuilder.AppendLine($"// {methodSymbol.Name}");

        string methodReturn = this.GenerateMethodReturn(methodSymbol);

        bool isUnsupported = string.IsNullOrWhiteSpace(methodReturn);
        if (isUnsupported)
        {
            if (!this.syntaxHelper.ClassContainsMethod(classDeclarationSyntax, methodSymbol))
            {
                var unsupportedType = Diagnostic.Create(
                    this.unsupportedReturnTypeDescriptor,
                    location,
                    methodSymbol.ReturnType.Name);

                context.ReportDiagnostic(unsupportedType);
            }

            return;
        }

        codeBuilder.Append("public ");

        codeBuilder.Append(methodSymbol.ReturnType.ToDisplayString());
        codeBuilder.Append(" ");
        codeBuilder.Append(methodSymbol.Name);
        codeBuilder.Append("(");
        codeBuilder.Append(string.Join(", ", parameters));
        codeBuilder.Append(")");

        if (!string.IsNullOrWhiteSpace(methodReturn))
        {
            codeBuilder.AppendLine();
            codeBuilder.AppendLine(methodReturn);
        }
        else
        {
            codeBuilder.AppendLine(";");
        }
    }

    private void GeneratePropertyCode(SourceProductionContext context, Location location,
        ClassDeclarationSyntax classDeclarationSyntax, IPropertySymbol propertySymbol,
        IndentedStringBuilder codeBuilder)
    {
        if (propertySymbol.GetMethod is not null)
        {
            var typeInfo = this.nullObjectTypeInfoHandler.GetTypeInfo(propertySymbol.Type);

            if (!typeInfo.Supported)
            {
                if (!this.syntaxHelper.ClassContainsProperty(classDeclarationSyntax, propertySymbol))
                {
                    var unsupportedType = Diagnostic.Create(
                        this.unsupportedReturnTypeDescriptor,
                        location,
                        propertySymbol.Type.Name);

                    context.ReportDiagnostic(unsupportedType);
                }

                return;
            }


            if (propertySymbol.SetMethod is null)
            {
                // Get only
                codeBuilder.AppendLine(
                    $"public {propertySymbol.Type.ToDisplayString()} {propertySymbol.Name} => {typeInfo.ReturnValue};");
            }
            else
            {
                // Get and Set
                codeBuilder.AppendLine(
                    $"public {propertySymbol.Type.ToDisplayString()} {propertySymbol.Name}");
                codeBuilder.AppendLine("{");
                codeBuilder.AppendLine($"get => {typeInfo.ReturnValue};");
                codeBuilder.AppendLine("set => _ = value;");
                codeBuilder.AppendLine("}");
            }
        }
    }

    private static List<string> GeneratorParameterList(IMethodSymbol ms)
    {
        List<string> parameters = new();

        foreach (IParameterSymbol parameterSymbol in ms.Parameters)
        {
            parameters.Add($"{parameterSymbol.Type.ToDisplayString()} {parameterSymbol.Name}");
        }

        return parameters;
    }

    private string GenerateMethodReturn(IMethodSymbol ms)
    {
        if (ms.ReturnsVoid)
        {
            return "{ }";
        }

        var typeInfo = this.nullObjectTypeInfoHandler.GetTypeInfo(ms.ReturnType);

        if (typeInfo.Supported)
        {
            if (typeInfo.IncludeReturn)
            {
                return $$"""
                         {
                            return {{typeInfo.ReturnValue}};
                         }
                         """;
            }
            else
            {
                return $$"""
                         {
                            {{typeInfo.ReturnValue}};
                         }
                         """;
            }
        }

        return string.Empty;
    }
}